// Code generated by protoc-gen-go. DO NOT EDIT.
// source: networking/v1alpha3/envoy_filter.proto

// `EnvoyFilter` provides a mechanism to customize the Envoy
// configuration generated by Istio Pilot. Use EnvoyFilter to modify
// values for certain fields, add specific filters, or even add
// entirely new listeners, clusters, etc. This feature must be used
// with care, as incorrect configurations could potentially
// destabilize the entire mesh. Unlike other Istio networking objects,
// EnvoyFilters are additively applied. Any number of EnvoyFilters can
// exist for a given workload in a specific namespace. The order of
// application of these EnvoyFilters is as follows: all EnvoyFilters
// in the config [root
// namespace](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig),
// followed by all matching EnvoyFilters in the workload's namespace.
//
// **NOTE 1**: Some aspects of this API is deeply tied to the internal
// implementation in Istio networking subsystem as well as Envoy's XDS
// API. While the EnvoyFilter API by itself will maintain backward
// compatibility, any envoy configuration provided through this
// mechanism should be carefully monitored across Istio proxy version
// upgrades, to ensure that deprecated fields are removed and replaced
// appropriately.
//
// **NOTE 2**: When multiple EnvoyFilters are bound to the same
// workload in a given namespace, all patches will be processed
// sequentially in order of creation time.  The behavior is undefined
// if multiple EnvoyFilter configurations conflict with each other.
//
// **NOTE 3**: To apply an EnvoyFilter resource to all workloads
// (sidecars and gateways) in the system, define the resource in the
// config [root
// namespace](https://istio.io/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig),
// without a workloadSelector.
//
// The example below declares a global default EnvoyFilter resource in
// the root namespace called `istio-config`, that adds a custom
// protocol filter on all sidecars in the system, for outbound port
// 9307. The filter should be added before the terminating tcp_proxy
// filter to take effect. In addition, it sets a 30s idle timeout for
// all HTTP connections in both gateways and sidecars.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: custom-protocol
//   namespace: istio-config # as defined in meshConfig resource.
// spec:
//   configPatches:
//   - applyTo: NETWORK_FILTER
//     match:
//       context: SIDECAR_OUTBOUND # will match outbound listeners in all sidecars
//       listener:
//         portNumber: 9307
//         filterChain:
//           filter:
//             name: "envoy.filters.network.tcp_proxy"
//     patch:
//       operation: INSERT_BEFORE
//       value:
//         # This is the full filter config including the name and typed_config section.
//         name: "envoy.config.filter.network.custom_protocol"
//         typed_config:
//          ...
//   - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
//     match:
//       # context omitted so that this applies to both sidecars and gateways
//       listener:
//         filterChain:
//           filter:
//             name: "envoy.filters.network.http_connection_manager"
//     patch:
//       operation: MERGE
//       value:
//         name: "envoy.filters.network.http_connection_manager"
//         typed_config:
//           "@type": "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
//           common_http_protocol_options:
//             idle_timeout: 30s
// ```
//
// The following example enables Envoy's Lua filter for all inbound
// HTTP calls arriving at service port 8080 of the reviews service pod
// with labels "app: reviews", in the bookinfo namespace. The lua
// filter calls out to an external service internal.org.net:8888 that
// requires a special cluster definition in envoy. The cluster is also
// added to the sidecar as part of this configuration.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-lua
//   namespace: bookinfo
// spec:
//   workloadSelector:
//     labels:
//       app: reviews
//   configPatches:
//     # The first patch adds the lua filter to the listener/http connection manager
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//       listener:
//         portNumber: 8080
//         filterChain:
//           filter:
//             name: "envoy.filters.network.http_connection_manager"
//             subFilter:
//               name: "envoy.filters.http.router"
//     patch:
//       operation: INSERT_BEFORE
//       value: # lua filter specification
//        name: envoy.lua
//        typed_config:
//           "@type": "type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua"
//           inlineCode: |
//             function envoy_on_request(request_handle)
//               -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
//               local headers, body = request_handle:httpCall(
//                "lua_cluster",
//                {
//                 [":method"] = "POST",
//                 [":path"] = "/acl",
//                 [":authority"] = "internal.org.net"
//                },
//               "authorize call",
//               5000)
//             end
//   # The second patch adds the cluster that is referenced by the lua code
//   # cds match is omitted as a new cluster is being added
//   - applyTo: CLUSTER
//     match:
//       context: SIDECAR_OUTBOUND
//     patch:
//       operation: ADD
//       value: # cluster specification
//         name: "lua_cluster"
//         type: STRICT_DNS
//         connect_timeout: 0.5s
//         lb_policy: ROUND_ROBIN
//         load_assignment:
//           cluster_name: lua_cluster
//           endpoints:
//           - lb_endpoints:
//             - endpoint:
//                 address:
//                   socket_address:
//                     protocol: TCP
//                     address: "internal.org.net"
//                     port_value: 8888
// ```
//
// The following example overwrites certain fields (HTTP idle timeout
// and X-Forward-For trusted hops) in the HTTP connection manager in a
// listener on the ingress gateway in istio-system namespace for the
// SNI host app.example.com:
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: hcm-tweaks
//   namespace: istio-system
// spec:
//   workloadSelector:
//     labels:
//       istio: ingressgateway
//   configPatches:
//   - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
//     match:
//       context: GATEWAY
//       listener:
//         filterChain:
//           sni: app.example.com
//           filter:
//             name: "envoy.filters.network.http_connection_manager"
//     patch:
//       operation: MERGE
//       value:
//         typed_config:
//           "@type": "type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager"
//           xff_num_trusted_hops: 5
//           common_http_protocol_options:
//             idle_timeout: 30s
// ```
//
// The following example inserts an attributegen filter
// that produces `istio_operationId` attribute which is consumed
// by the istio.stats fiter. `filterClass: STATS` encodes this dependency.
//
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: reviews-request-operation
//   namespace: myns
// spec:
//   workloadSelector:
//     labels:
//       app: reviews
//   configPatches:
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//     patch:
//       operation: ADD
//       filterClass: STATS # This filter will run *before* the Istio stats filter.
//       value:
//         name: istio.request_operation
//         typed_config:
//          "@type": type.googleapis.com/udpa.type.v1.TypedStruct
//          type_url: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
//          value:
//            config:
//              configuration: |
//                {
//                  "attributes": [
//                    {
//                      "output_attribute": "istio_operationId",
//                      "match": [
//                        {
//                          "value": "ListReviews",
//                          "condition": "request.url_path == '/reviews' && request.method == 'GET'"
//                        }]
//                    }]
//                }
//              vm_config:
//                runtime: envoy.wasm.runtime.null
//                code:
//                  local: { inline_string: "envoy.wasm.attributegen" }
// ```
//
// The following example inserts an http ext_authz filter in the `myns` namespace.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: myns-ext-authz
//   namespace: myns
// spec:
//   configPatches:
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//     patch:
//       operation: ADD
//       filterClass: AUTHZ # This filter will run *after* the Istio authz filter.
//       value:
//         name: envoy.filters.http.ext_authz
//         typed_config:
//           "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
//           grpc_service:
//             envoy_grpc:
//               cluster_name: acme-ext-authz
//             initial_metadata:
//             - key: foo
//               value: myauth.acme # required by local ext auth server.
// ```
//
// A workload in the `myns` namespace needs to access a different ext_auth server
// that does not accept initial metadata. Since proto merge cannot remove fields, the
// following configuration uses the `REPLACE` operation. If you do not need to inherit
// fields, REPLACE is preferred over MERGE.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: mysvc-ext-authz
//   namespace: myns
// spec:
//   workloadSelector:
//     labels:
//       app: mysvc
//   configPatches:
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//     patch:
//       operation: REPLACE
//       value:
//         name: envoy.filters.http.ext_authz
//         typed_config:
//           "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
//           grpc_service:
//             envoy_grpc:
//               cluster_name: acme-ext-authz-alt
// ```
//
// The following example deploys a Wasm extension for all inbound sidecar HTTP requests.
//
// ```yaml
// apiVersion: networking.istio.io/v1alpha3
// kind: EnvoyFilter
// metadata:
//   name: wasm-example
//   namespace: myns
// spec:
//   configPatches:
//   # The first patch defines a named Wasm extension and provides a URL to fetch Wasm binary from,
//   # and the binary configuration. It should come before the next patch that applies it.
//   # This resource is visible to all proxies in the namespace "myns". It is possible to provide
//   # multiple definitions for the same name "my-wasm-extension" in multiple namespaces. We recommend that:
//   # - if overriding is desired, then the root level definition can be overriden per namespace with REPLACE.
//   # - if overriding is not desired, then the name should be qualified with the namespace "myns/my-wasm-extension",
//   #   to avoid accidental name collisions.
//   - applyTo: EXTENSION_CONFIG
//     patch:
//       operation: ADD # REPLACE is also supported, and would override a cluster level resource with the same name.
//       value:
//         name: my-wasm-extension
//         typed_config:
//           "@type": type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
//           config:
//             root_id: my-wasm-root-id
//             vm_config:
//               vm_id: my-wasm-vm-id
//               runtime: envoy.wasm.runtime.v8
//               code:
//                 remote:
//                   http_uri:
//                     uri: http://my-wasm-binary-uri
//             configuration:
//               "@type": "type.googleapis.com/google.protobuf.StringValue"
//               value: |
//                 {}
//   # The second patch instructs to apply the above Wasm filter to the listener/http connection manager.
//   - applyTo: HTTP_FILTER
//     match:
//       context: SIDECAR_INBOUND
//     patch:
//       operation: ADD
//       filterClass: AUTHZ # This filter will run *after* the Istio authz filter.
//       value:
//         name: my-wasm-extension # This must match the name above
//         config_discovery:
//           config_source:
//             api_config_source:
//               api_type: GRPC
//               transport_api_version: V3
//               grpc_services:
//               - envoy_grpc:
//                   cluster_name: xds-grpc
//           type_urls: ["envoy.extensions.filters.http.wasm.v3.Wasm"]
// ```

package v1alpha3

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// `ApplyTo` specifies where in the Envoy configuration, the given patch should be applied.
type EnvoyFilter_ApplyTo int32

const (
	EnvoyFilter_INVALID EnvoyFilter_ApplyTo = 0
	// Applies the patch to the listener.
	EnvoyFilter_LISTENER EnvoyFilter_ApplyTo = 1
	// Applies the patch to the filter chain.
	EnvoyFilter_FILTER_CHAIN EnvoyFilter_ApplyTo = 2
	// Applies the patch to the network filter chain, to modify an
	// existing filter or add a new filter.
	EnvoyFilter_NETWORK_FILTER EnvoyFilter_ApplyTo = 3
	// Applies the patch to the HTTP filter chain in the http
	// connection manager, to modify an existing filter or add a new
	// filter.
	EnvoyFilter_HTTP_FILTER EnvoyFilter_ApplyTo = 4
	// Applies the patch to the Route configuration (rds output)
	// inside a HTTP connection manager. This does not apply to the
	// virtual host. Currently, only `MERGE` operation is allowed on the
	// route configuration objects.
	EnvoyFilter_ROUTE_CONFIGURATION EnvoyFilter_ApplyTo = 5
	// Applies the patch to a virtual host inside a route configuration.
	EnvoyFilter_VIRTUAL_HOST EnvoyFilter_ApplyTo = 6
	// Applies the patch to a route object inside the matched virtual
	// host in a route configuration.
	EnvoyFilter_HTTP_ROUTE EnvoyFilter_ApplyTo = 7
	// Applies the patch to a cluster in a CDS output. Also used to add new clusters.
	EnvoyFilter_CLUSTER EnvoyFilter_ApplyTo = 8
	// Applies the patch to or adds an extension config in ECDS output. Note that ECDS
	// is only supported by HTTP filters.
	EnvoyFilter_EXTENSION_CONFIG EnvoyFilter_ApplyTo = 9
)

var EnvoyFilter_ApplyTo_name = map[int32]string{
	0: "INVALID",
	1: "LISTENER",
	2: "FILTER_CHAIN",
	3: "NETWORK_FILTER",
	4: "HTTP_FILTER",
	5: "ROUTE_CONFIGURATION",
	6: "VIRTUAL_HOST",
	7: "HTTP_ROUTE",
	8: "CLUSTER",
	9: "EXTENSION_CONFIG",
}

var EnvoyFilter_ApplyTo_value = map[string]int32{
	"INVALID":             0,
	"LISTENER":            1,
	"FILTER_CHAIN":        2,
	"NETWORK_FILTER":      3,
	"HTTP_FILTER":         4,
	"ROUTE_CONFIGURATION": 5,
	"VIRTUAL_HOST":        6,
	"HTTP_ROUTE":          7,
	"CLUSTER":             8,
	"EXTENSION_CONFIG":    9,
}

func (x EnvoyFilter_ApplyTo) String() string {
	return proto.EnumName(EnvoyFilter_ApplyTo_name, int32(x))
}

func (EnvoyFilter_ApplyTo) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0}
}

// PatchContext selects a class of configurations based on the
// traffic flow direction and workload type.
type EnvoyFilter_PatchContext int32

const (
	// All listeners/routes/clusters in both sidecars and gateways.
	EnvoyFilter_ANY EnvoyFilter_PatchContext = 0
	// Inbound listener/route/cluster in sidecar.
	EnvoyFilter_SIDECAR_INBOUND EnvoyFilter_PatchContext = 1
	// Outbound listener/route/cluster in sidecar.
	EnvoyFilter_SIDECAR_OUTBOUND EnvoyFilter_PatchContext = 2
	// Gateway listener/route/cluster.
	EnvoyFilter_GATEWAY EnvoyFilter_PatchContext = 3
)

var EnvoyFilter_PatchContext_name = map[int32]string{
	0: "ANY",
	1: "SIDECAR_INBOUND",
	2: "SIDECAR_OUTBOUND",
	3: "GATEWAY",
}

var EnvoyFilter_PatchContext_value = map[string]int32{
	"ANY":              0,
	"SIDECAR_INBOUND":  1,
	"SIDECAR_OUTBOUND": 2,
	"GATEWAY":          3,
}

func (x EnvoyFilter_PatchContext) String() string {
	return proto.EnumName(EnvoyFilter_PatchContext_name, int32(x))
}

func (EnvoyFilter_PatchContext) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 1}
}

// Action refers to the route action taken by Envoy when a http route matches.
type EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action int32

const (
	// All three route actions
	EnvoyFilter_RouteConfigurationMatch_RouteMatch_ANY EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action = 0
	// Route traffic to a cluster / weighted clusters.
	EnvoyFilter_RouteConfigurationMatch_RouteMatch_ROUTE EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action = 1
	// Redirect request.
	EnvoyFilter_RouteConfigurationMatch_RouteMatch_REDIRECT EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action = 2
	// directly respond to a request with specific payload.
	EnvoyFilter_RouteConfigurationMatch_RouteMatch_DIRECT_RESPONSE EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action = 3
)

var EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action_name = map[int32]string{
	0: "ANY",
	1: "ROUTE",
	2: "REDIRECT",
	3: "DIRECT_RESPONSE",
}

var EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action_value = map[string]int32{
	"ANY":             0,
	"ROUTE":           1,
	"REDIRECT":        2,
	"DIRECT_RESPONSE": 3,
}

func (x EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action) String() string {
	return proto.EnumName(EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action_name, int32(x))
}

func (EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2, 0, 0}
}

// Operation denotes how the patch should be applied to the selected
// configuration.
type EnvoyFilter_Patch_Operation int32

const (
	EnvoyFilter_Patch_INVALID EnvoyFilter_Patch_Operation = 0
	// Merge the provided config with the generated config using
	// proto merge semantics. If you are specifying config in its
	// entirety, use `REPLACE` instead.
	EnvoyFilter_Patch_MERGE EnvoyFilter_Patch_Operation = 1
	// Add the provided config to an existing list (of listeners,
	// clusters, virtual hosts, network filters, or http
	// filters). This operation will be ignored when `applyTo` is set
	// to `ROUTE_CONFIGURATION`, or `HTTP_ROUTE`.
	EnvoyFilter_Patch_ADD EnvoyFilter_Patch_Operation = 2
	// Remove the selected object from the list (of listeners,
	// clusters, virtual hosts, network filters, routes, or http
	// filters). Does not require a value to be specified. This
	// operation will be ignored when `applyTo` is set to
	// `ROUTE_CONFIGURATION`, or `HTTP_ROUTE`.
	EnvoyFilter_Patch_REMOVE EnvoyFilter_Patch_Operation = 3
	// Insert operation on an array of named objects. This operation
	// is typically useful only in the context of filters or routes,
	// where the order of elements matter. Routes should be ordered
	// based on most to least specific matching criteria since the
	// first matching element is selected. For clusters and virtual hosts,
	// order of the element in the array does not matter. Insert
	// before the selected filter or sub filter. If no filter is
	// selected, the specified filter will be inserted at the front
	// of the list.
	EnvoyFilter_Patch_INSERT_BEFORE EnvoyFilter_Patch_Operation = 4
	// Insert operation on an array of named objects. This operation
	// is typically useful only in the context of filters or routes,
	// where the order of elements matter. Routes should be ordered
	// based on most to least specific matching criteria since the
	// first matching element is selected. For clusters and virtual hosts,
	// order of the element in the array does not matter. Insert
	// after the selected filter or sub filter. If no filter is
	// selected, the specified filter will be inserted at the end
	// of the list.
	EnvoyFilter_Patch_INSERT_AFTER EnvoyFilter_Patch_Operation = 5
	// Insert operation on an array of named objects. This operation
	// is typically useful only in the context of filters or routes,
	// where the order of elements matter. Routes should be ordered
	// based on most to least specific matching criteria since the
	// first matching element is selected. For clusters and virtual hosts,
	// order of the element in the array does not matter. Insert
	// first in the list based on the presence of selected filter or not.
	// This is specifically useful when you want your filter first in the
	// list based on a match condition specified in Match clause.
	EnvoyFilter_Patch_INSERT_FIRST EnvoyFilter_Patch_Operation = 6
	// Replace contents of a named filter with new contents.
	// `REPLACE` operation is only valid for `HTTP_FILTER` and
	// `NETWORK_FILTER`. If the named filter is not found, this operation
	// has no effect.
	EnvoyFilter_Patch_REPLACE EnvoyFilter_Patch_Operation = 7
)

var EnvoyFilter_Patch_Operation_name = map[int32]string{
	0: "INVALID",
	1: "MERGE",
	2: "ADD",
	3: "REMOVE",
	4: "INSERT_BEFORE",
	5: "INSERT_AFTER",
	6: "INSERT_FIRST",
	7: "REPLACE",
}

var EnvoyFilter_Patch_Operation_value = map[string]int32{
	"INVALID":       0,
	"MERGE":         1,
	"ADD":           2,
	"REMOVE":        3,
	"INSERT_BEFORE": 4,
	"INSERT_AFTER":  5,
	"INSERT_FIRST":  6,
	"REPLACE":       7,
}

func (x EnvoyFilter_Patch_Operation) String() string {
	return proto.EnumName(EnvoyFilter_Patch_Operation_name, int32(x))
}

func (EnvoyFilter_Patch_Operation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 4, 0}
}

// FilterClass determines the filter insertion point in the filter chain
// relative to the filters implicitly inserted by the control plane.
// It is used in conjuction with the `ADD` operation.
// This is the preferred insertion mechanism for adding filters over
// the `INSERT_*` operations since those operations rely on potentially unstable
// filter names.
// Filter ordering is important if your filter depends on or affects the
// functioning of a another filter in the filter chain.
// Within a filter class, filters are inserted in the order of processing.
type EnvoyFilter_Patch_FilterClass int32

const (
	// Control plane decides where to insert the filter.
	// Do not specify `FilterClass` if the filter is independent of others.
	EnvoyFilter_Patch_UNSPECIFIED EnvoyFilter_Patch_FilterClass = 0
	// Insert filter after Istio authentication filters.
	EnvoyFilter_Patch_AUTHN EnvoyFilter_Patch_FilterClass = 1
	// Insert filter after Istio authorization filters.
	EnvoyFilter_Patch_AUTHZ EnvoyFilter_Patch_FilterClass = 2
	// Insert filter before Istio stats filters.
	EnvoyFilter_Patch_STATS EnvoyFilter_Patch_FilterClass = 3
)

var EnvoyFilter_Patch_FilterClass_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "AUTHN",
	2: "AUTHZ",
	3: "STATS",
}

var EnvoyFilter_Patch_FilterClass_value = map[string]int32{
	"UNSPECIFIED": 0,
	"AUTHN":       1,
	"AUTHZ":       2,
	"STATS":       3,
}

func (x EnvoyFilter_Patch_FilterClass) String() string {
	return proto.EnumName(EnvoyFilter_Patch_FilterClass_name, int32(x))
}

func (EnvoyFilter_Patch_FilterClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 4, 1}
}

// EnvoyFilter provides a mechanism to customize the Envoy configuration
// generated by Istio Pilot.
//
// <!-- crd generation tags
// +cue-gen:EnvoyFilter:groupName:networking.istio.io
// +cue-gen:EnvoyFilter:version:v1alpha3
// +cue-gen:EnvoyFilter:storageVersion
// +cue-gen:EnvoyFilter:annotations:helm.sh/resource-policy=keep
// +cue-gen:EnvoyFilter:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
// +cue-gen:EnvoyFilter:subresource:status
// +cue-gen:EnvoyFilter:scope:Namespaced
// +cue-gen:EnvoyFilter:resource:categories=istio-io,networking-istio-io
// +cue-gen:EnvoyFilter:preserveUnknownFields:configPatches.[].patch.value
// -->
//
// <!-- go code generation tags
// +kubetype-gen
// +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
// +genclient
// +k8s:deepcopy-gen=true
// -->
type EnvoyFilter struct {
	// Criteria used to select the specific set of pods/VMs on which
	// this patch configuration should be applied. If omitted, the set
	// of patches in this configuration will be applied to all workload
	// instances in the same namespace.  If omitted, the `EnvoyFilter`
	// patches will be applied to all workloads in the same
	// namespace. If the `EnvoyFilter` is present in the config root
	// namespace, it will be applied to all applicable workloads in any
	// namespace.
	WorkloadSelector *WorkloadSelector `protobuf:"bytes,3,opt,name=workload_selector,json=workloadSelector,proto3" json:"workload_selector,omitempty"`
	// One or more patches with match conditions.
	ConfigPatches        []*EnvoyFilter_EnvoyConfigObjectPatch `protobuf:"bytes,4,rep,name=config_patches,json=configPatches,proto3" json:"config_patches,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                              `json:"-"`
	XXX_unrecognized     []byte                                `json:"-"`
	XXX_sizecache        int32                                 `json:"-"`
}

func (m *EnvoyFilter) Reset()         { *m = EnvoyFilter{} }
func (m *EnvoyFilter) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter) ProtoMessage()    {}
func (*EnvoyFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0}
}

func (m *EnvoyFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter.Unmarshal(m, b)
}
func (m *EnvoyFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter.Merge(m, src)
}
func (m *EnvoyFilter) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter.Size(m)
}
func (m *EnvoyFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter proto.InternalMessageInfo

func (m *EnvoyFilter) GetWorkloadSelector() *WorkloadSelector {
	if m != nil {
		return m.WorkloadSelector
	}
	return nil
}

func (m *EnvoyFilter) GetConfigPatches() []*EnvoyFilter_EnvoyConfigObjectPatch {
	if m != nil {
		return m.ConfigPatches
	}
	return nil
}

// One or more properties of the proxy to match on.
type EnvoyFilter_ProxyMatch struct {
	// A regular expression in golang regex format (RE2) that can be
	// used to select proxies using a specific version of istio
	// proxy. The Istio version for a given proxy is obtained from the
	// node metadata field `ISTIO_VERSION` supplied by the proxy when
	// connecting to Pilot. This value is embedded as an environment
	// variable (`ISTIO_META_ISTIO_VERSION`) in the Istio proxy docker
	// image. Custom proxy implementations should provide this metadata
	// variable to take advantage of the Istio version check option.
	ProxyVersion string `protobuf:"bytes,1,opt,name=proxy_version,json=proxyVersion,proto3" json:"proxy_version,omitempty"`
	// Match on the node metadata supplied by a proxy when connecting
	// to Istio Pilot. Note that while Envoy's node metadata is of
	// type Struct, only string key-value pairs are processed by
	// Pilot. All keys specified in the metadata must match with exact
	// values. The match will fail if any of the specified keys are
	// absent or the values fail to match.
	Metadata             map[string]string `protobuf:"bytes,2,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EnvoyFilter_ProxyMatch) Reset()         { *m = EnvoyFilter_ProxyMatch{} }
func (m *EnvoyFilter_ProxyMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ProxyMatch) ProtoMessage()    {}
func (*EnvoyFilter_ProxyMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 0}
}

func (m *EnvoyFilter_ProxyMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ProxyMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ProxyMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ProxyMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ProxyMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ProxyMatch.Merge(m, src)
}
func (m *EnvoyFilter_ProxyMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ProxyMatch.Size(m)
}
func (m *EnvoyFilter_ProxyMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ProxyMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ProxyMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ProxyMatch) GetProxyVersion() string {
	if m != nil {
		return m.ProxyVersion
	}
	return ""
}

func (m *EnvoyFilter_ProxyMatch) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Conditions specified in `ClusterMatch` must be met for the patch
// to be applied to a cluster.
type EnvoyFilter_ClusterMatch struct {
	// The service port for which this cluster was generated.  If
	// omitted, applies to clusters for any port.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// The fully qualified service name for this cluster. If omitted,
	// applies to clusters for any service. For services defined
	// through service entries, the service name is same as the hosts
	// defined in the service entry.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty"`
	// The subset associated with the service. If omitted, applies to
	// clusters for any subset of a service.
	Subset string `protobuf:"bytes,3,opt,name=subset,proto3" json:"subset,omitempty"`
	// The exact name of the cluster to match. To match a specific
	// cluster by name, such as the internally generated `Passthrough`
	// cluster, leave all fields in clusterMatch empty, except the
	// name.
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ClusterMatch) Reset()         { *m = EnvoyFilter_ClusterMatch{} }
func (m *EnvoyFilter_ClusterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ClusterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ClusterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 1}
}

func (m *EnvoyFilter_ClusterMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ClusterMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ClusterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ClusterMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ClusterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ClusterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ClusterMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ClusterMatch.Size(m)
}
func (m *EnvoyFilter_ClusterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ClusterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ClusterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ClusterMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_ClusterMatch) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *EnvoyFilter_ClusterMatch) GetSubset() string {
	if m != nil {
		return m.Subset
	}
	return ""
}

func (m *EnvoyFilter_ClusterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Conditions specified in RouteConfigurationMatch must be met for
// the patch to be applied to a route configuration object or a
// specific virtual host within the route configuration.
type EnvoyFilter_RouteConfigurationMatch struct {
	// The service port number or gateway server port number for which
	// this route configuration was generated. If omitted, applies to
	// route configurations for all ports.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// Applicable only for GATEWAY context. The gateway server port
	// name for which this route configuration was generated.
	PortName string `protobuf:"bytes,2,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	// The Istio gateway config's namespace/name for which this route
	// configuration was generated. Applies only if the context is
	// GATEWAY. Should be in the namespace/name format. Use this field
	// in conjunction with the `portNumber` and `portName` to accurately
	// select the Envoy route configuration for a specific HTTPS
	// server within a gateway config object.
	Gateway string `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`
	// Match a specific virtual host in a route configuration and
	// apply the patch to the virtual host.
	Vhost *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch `protobuf:"bytes,4,opt,name=vhost,proto3" json:"vhost,omitempty"`
	// Route configuration name to match on. Can be used to match a
	// specific route configuration by name, such as the internally
	// generated `http_proxy` route configuration for all sidecars.
	Name                 string   `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_RouteConfigurationMatch) Reset()         { *m = EnvoyFilter_RouteConfigurationMatch{} }
func (m *EnvoyFilter_RouteConfigurationMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_RouteConfigurationMatch) ProtoMessage()    {}
func (*EnvoyFilter_RouteConfigurationMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2}
}

func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Merge(m, src)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.Size(m)
}
func (m *EnvoyFilter_RouteConfigurationMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch proto.InternalMessageInfo

func (m *EnvoyFilter_RouteConfigurationMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetPortName() string {
	if m != nil {
		return m.PortName
	}
	return ""
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetGateway() string {
	if m != nil {
		return m.Gateway
	}
	return ""
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetVhost() *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch {
	if m != nil {
		return m.Vhost
	}
	return nil
}

func (m *EnvoyFilter_RouteConfigurationMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Match a specific route inside a virtual host in a route configuration.
type EnvoyFilter_RouteConfigurationMatch_RouteMatch struct {
	// The Route objects generated by default are named as
	// default.  Route objects generated using a virtual service
	// will carry the name used in the virtual service's HTTP
	// routes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Match a route with specific action type.
	Action               EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action `protobuf:"varint,2,opt,name=action,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                              `json:"-"`
	XXX_unrecognized     []byte                                                `json:"-"`
	XXX_sizecache        int32                                                 `json:"-"`
}

func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) Reset() {
	*m = EnvoyFilter_RouteConfigurationMatch_RouteMatch{}
}
func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) String() string {
	return proto.CompactTextString(m)
}
func (*EnvoyFilter_RouteConfigurationMatch_RouteMatch) ProtoMessage() {}
func (*EnvoyFilter_RouteConfigurationMatch_RouteMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2, 0}
}

func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch.Merge(m, src)
}
func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch.Size(m)
}
func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_RouteMatch proto.InternalMessageInfo

func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvoyFilter_RouteConfigurationMatch_RouteMatch) GetAction() EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action {
	if m != nil {
		return m.Action
	}
	return EnvoyFilter_RouteConfigurationMatch_RouteMatch_ANY
}

// Match a specific virtual host inside a route configuration.
type EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch struct {
	// The VirtualHosts objects generated by Istio are named as
	// host:port, where the host typically corresponds to the
	// VirtualService's host field or the hostname of a service in the
	// registry.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Match a specific route within the virtual host.
	Route                *EnvoyFilter_RouteConfigurationMatch_RouteMatch `protobuf:"bytes,2,opt,name=route,proto3" json:"route,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                        `json:"-"`
	XXX_unrecognized     []byte                                          `json:"-"`
	XXX_sizecache        int32                                           `json:"-"`
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Reset() {
	*m = EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch{}
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) String() string {
	return proto.CompactTextString(m)
}
func (*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) ProtoMessage() {}
func (*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 2, 1}
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Merge(m, src)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.Size(m)
}
func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch proto.InternalMessageInfo

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch) GetRoute() *EnvoyFilter_RouteConfigurationMatch_RouteMatch {
	if m != nil {
		return m.Route
	}
	return nil
}

// Conditions specified in a listener match must be met for the
// patch to be applied to a specific listener across all filter
// chains, or a specific filter chain inside the listener.
type EnvoyFilter_ListenerMatch struct {
	// The service port/gateway port to which traffic is being
	// sent/received. If not specified, matches all listeners. Even though
	// inbound listeners are generated for the instance/pod ports, only
	// service ports should be used to match listeners.
	PortNumber uint32 `protobuf:"varint,1,opt,name=port_number,json=portNumber,proto3" json:"port_number,omitempty"`
	// Instead of using specific port numbers, a set of ports matching
	// a given service's port name can be selected. Matching is case
	// insensitive.
	// Not implemented.
	// $hide_from_docs
	PortName string `protobuf:"bytes,2,opt,name=port_name,json=portName,proto3" json:"port_name,omitempty"`
	// Match a specific filter chain in a listener. If specified, the
	// patch will be applied to the filter chain (and a specific
	// filter if specified) and not to other filter chains in the
	// listener.
	FilterChain *EnvoyFilter_ListenerMatch_FilterChainMatch `protobuf:"bytes,3,opt,name=filter_chain,json=filterChain,proto3" json:"filter_chain,omitempty"`
	// Match a specific listener by its name. The listeners generated
	// by Pilot are typically named as IP:Port.
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch) Reset()         { *m = EnvoyFilter_ListenerMatch{} }
func (m *EnvoyFilter_ListenerMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 3}
}

func (m *EnvoyFilter_ListenerMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ListenerMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ListenerMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch.Size(m)
}
func (m *EnvoyFilter_ListenerMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch) GetPortNumber() uint32 {
	if m != nil {
		return m.PortNumber
	}
	return 0
}

func (m *EnvoyFilter_ListenerMatch) GetPortName() string {
	if m != nil {
		return m.PortName
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch) GetFilterChain() *EnvoyFilter_ListenerMatch_FilterChainMatch {
	if m != nil {
		return m.FilterChain
	}
	return nil
}

func (m *EnvoyFilter_ListenerMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// For listeners with multiple filter chains (e.g., inbound
// listeners on sidecars with permissive mTLS, gateway listeners
// with multiple SNI matches), the filter chain match can be used
// to select a specific filter chain to patch.
type EnvoyFilter_ListenerMatch_FilterChainMatch struct {
	// The name assigned to the filter chain.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The SNI value used by a filter chain's match condition.  This
	// condition will evaluate to false if the filter chain has no
	// sni match.
	Sni string `protobuf:"bytes,2,opt,name=sni,proto3" json:"sni,omitempty"`
	// Applies only to `SIDECAR_INBOUND` context. If non-empty, a
	// transport protocol to consider when determining a filter
	// chain match.  This value will be compared against the
	// transport protocol of a new connection, when it's detected by
	// the `tls_inspector` listener filter.
	//
	// Accepted values include:
	//
	// * `raw_buffer` - default, used when no transport protocol is detected.
	// * `tls` - set when TLS protocol is detected by the TLS inspector.
	TransportProtocol string `protobuf:"bytes,3,opt,name=transport_protocol,json=transportProtocol,proto3" json:"transport_protocol,omitempty"`
	// Applies only to sidecars. If non-empty, a comma separated set
	// of application protocols to consider when determining a
	// filter chain match.  This value will be compared against the
	// application protocols of a new connection, when it's detected
	// by one of the listener filters such as the `http_inspector`.
	//
	// Accepted values include: h2, http/1.1, http/1.0
	ApplicationProtocols string `protobuf:"bytes,4,opt,name=application_protocols,json=applicationProtocols,proto3" json:"application_protocols,omitempty"`
	// The name of a specific filter to apply the patch to. Set this
	// to `envoy.filters.network.http_connection_manager` to add a filter or apply a
	// patch to the HTTP connection manager.
	Filter *EnvoyFilter_ListenerMatch_FilterMatch `protobuf:"bytes,5,opt,name=filter,proto3" json:"filter,omitempty"`
	// The destination_port value used by a filter chain's match condition.
	// This condition will evaluate to false if the filter chain has no destination_port match.
	DestinationPort      uint32   `protobuf:"varint,6,opt,name=destination_port,json=destinationPort,proto3" json:"destination_port,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) Reset() {
	*m = EnvoyFilter_ListenerMatch_FilterChainMatch{}
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) String() string {
	return proto.CompactTextString(m)
}
func (*EnvoyFilter_ListenerMatch_FilterChainMatch) ProtoMessage() {}
func (*EnvoyFilter_ListenerMatch_FilterChainMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 3, 0}
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.Size(m)
}
func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterChainMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetSni() string {
	if m != nil {
		return m.Sni
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetTransportProtocol() string {
	if m != nil {
		return m.TransportProtocol
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetApplicationProtocols() string {
	if m != nil {
		return m.ApplicationProtocols
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetFilter() *EnvoyFilter_ListenerMatch_FilterMatch {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *EnvoyFilter_ListenerMatch_FilterChainMatch) GetDestinationPort() uint32 {
	if m != nil {
		return m.DestinationPort
	}
	return 0
}

// Conditions to match a specific filter within a filter chain.
type EnvoyFilter_ListenerMatch_FilterMatch struct {
	// The filter name to match on.
	// For standard Envoy filters, [canonical filter](https://www.envoyproxy.io/docs/envoy/latest/version_history/v1.14.0#deprecated)
	// names should be used.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The next level filter within this filter to match
	// upon. Typically used for HTTP Connection Manager filters and
	// Thrift filters.
	SubFilter            *EnvoyFilter_ListenerMatch_SubFilterMatch `protobuf:"bytes,2,opt,name=sub_filter,json=subFilter,proto3" json:"sub_filter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) Reset()         { *m = EnvoyFilter_ListenerMatch_FilterMatch{} }
func (m *EnvoyFilter_ListenerMatch_FilterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch_FilterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch_FilterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 3, 1}
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.Size(m)
}
func (m *EnvoyFilter_ListenerMatch_FilterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_FilterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_FilterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EnvoyFilter_ListenerMatch_FilterMatch) GetSubFilter() *EnvoyFilter_ListenerMatch_SubFilterMatch {
	if m != nil {
		return m.SubFilter
	}
	return nil
}

// Conditions to match a specific filter within another
// filter. This field is typically useful to match a HTTP filter
// inside the `envoy.filters.network.http_connection_manager` network filter.
// This could also be applicable for thrift filters.
type EnvoyFilter_ListenerMatch_SubFilterMatch struct {
	// The filter name to match on.
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) Reset() {
	*m = EnvoyFilter_ListenerMatch_SubFilterMatch{}
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_ListenerMatch_SubFilterMatch) ProtoMessage()    {}
func (*EnvoyFilter_ListenerMatch_SubFilterMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 3, 2}
}

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Merge(m, src)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.Size(m)
}
func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_ListenerMatch_SubFilterMatch proto.InternalMessageInfo

func (m *EnvoyFilter_ListenerMatch_SubFilterMatch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Patch specifies how the selected object should be modified.
type EnvoyFilter_Patch struct {
	// Determines how the patch should be applied.
	Operation EnvoyFilter_Patch_Operation `protobuf:"varint,1,opt,name=operation,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_Patch_Operation" json:"operation,omitempty"`
	// The JSON config of the object being patched. This will be merged using
	// proto merge semantics with the existing proto in the path.
	Value *_struct.Struct `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Determines the filter insertion order.
	FilterClass          EnvoyFilter_Patch_FilterClass `protobuf:"varint,3,opt,name=filter_class,json=filterClass,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_Patch_FilterClass" json:"filter_class,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *EnvoyFilter_Patch) Reset()         { *m = EnvoyFilter_Patch{} }
func (m *EnvoyFilter_Patch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_Patch) ProtoMessage()    {}
func (*EnvoyFilter_Patch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 4}
}

func (m *EnvoyFilter_Patch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_Patch.Unmarshal(m, b)
}
func (m *EnvoyFilter_Patch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_Patch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_Patch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_Patch.Merge(m, src)
}
func (m *EnvoyFilter_Patch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_Patch.Size(m)
}
func (m *EnvoyFilter_Patch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_Patch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_Patch proto.InternalMessageInfo

func (m *EnvoyFilter_Patch) GetOperation() EnvoyFilter_Patch_Operation {
	if m != nil {
		return m.Operation
	}
	return EnvoyFilter_Patch_INVALID
}

func (m *EnvoyFilter_Patch) GetValue() *_struct.Struct {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *EnvoyFilter_Patch) GetFilterClass() EnvoyFilter_Patch_FilterClass {
	if m != nil {
		return m.FilterClass
	}
	return EnvoyFilter_Patch_UNSPECIFIED
}

// One or more match conditions to be met before a patch is applied
// to the generated configuration for a given proxy.
type EnvoyFilter_EnvoyConfigObjectMatch struct {
	// The specific config generation context to match on. Istio Pilot
	// generates envoy configuration in the context of a gateway,
	// inbound traffic to sidecar and outbound traffic from sidecar.
	Context EnvoyFilter_PatchContext `protobuf:"varint,1,opt,name=context,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_PatchContext" json:"context,omitempty"`
	// Match on properties associated with a proxy.
	Proxy *EnvoyFilter_ProxyMatch `protobuf:"bytes,2,opt,name=proxy,proto3" json:"proxy,omitempty"`
	// Types that are valid to be assigned to ObjectTypes:
	//	*EnvoyFilter_EnvoyConfigObjectMatch_Listener
	//	*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration
	//	*EnvoyFilter_EnvoyConfigObjectMatch_Cluster
	ObjectTypes          isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes `protobuf_oneof:"object_types"`
	XXX_NoUnkeyedLiteral struct{}                                         `json:"-"`
	XXX_unrecognized     []byte                                           `json:"-"`
	XXX_sizecache        int32                                            `json:"-"`
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) Reset()         { *m = EnvoyFilter_EnvoyConfigObjectMatch{} }
func (m *EnvoyFilter_EnvoyConfigObjectMatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_EnvoyConfigObjectMatch) ProtoMessage()    {}
func (*EnvoyFilter_EnvoyConfigObjectMatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 5}
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Merge(m, src)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.Size(m)
}
func (m *EnvoyFilter_EnvoyConfigObjectMatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectMatch proto.InternalMessageInfo

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetContext() EnvoyFilter_PatchContext {
	if m != nil {
		return m.Context
	}
	return EnvoyFilter_ANY
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetProxy() *EnvoyFilter_ProxyMatch {
	if m != nil {
		return m.Proxy
	}
	return nil
}

type isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes interface {
	isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes()
}

type EnvoyFilter_EnvoyConfigObjectMatch_Listener struct {
	Listener *EnvoyFilter_ListenerMatch `protobuf:"bytes,3,opt,name=listener,proto3,oneof"`
}

type EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration struct {
	RouteConfiguration *EnvoyFilter_RouteConfigurationMatch `protobuf:"bytes,4,opt,name=route_configuration,json=routeConfiguration,proto3,oneof"`
}

type EnvoyFilter_EnvoyConfigObjectMatch_Cluster struct {
	Cluster *EnvoyFilter_ClusterMatch `protobuf:"bytes,5,opt,name=cluster,proto3,oneof"`
}

func (*EnvoyFilter_EnvoyConfigObjectMatch_Listener) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}

func (*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}

func (*EnvoyFilter_EnvoyConfigObjectMatch_Cluster) isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes() {
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetObjectTypes() isEnvoyFilter_EnvoyConfigObjectMatch_ObjectTypes {
	if m != nil {
		return m.ObjectTypes
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetListener() *EnvoyFilter_ListenerMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_Listener); ok {
		return x.Listener
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetRouteConfiguration() *EnvoyFilter_RouteConfigurationMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration); ok {
		return x.RouteConfiguration
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectMatch) GetCluster() *EnvoyFilter_ClusterMatch {
	if x, ok := m.GetObjectTypes().(*EnvoyFilter_EnvoyConfigObjectMatch_Cluster); ok {
		return x.Cluster
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EnvoyFilter_EnvoyConfigObjectMatch) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EnvoyFilter_EnvoyConfigObjectMatch_Listener)(nil),
		(*EnvoyFilter_EnvoyConfigObjectMatch_RouteConfiguration)(nil),
		(*EnvoyFilter_EnvoyConfigObjectMatch_Cluster)(nil),
	}
}

// Changes to be made to various envoy config objects.
type EnvoyFilter_EnvoyConfigObjectPatch struct {
	// Specifies where in the Envoy configuration, the patch should be
	// applied.  The match is expected to select the appropriate
	// object based on applyTo.  For example, an applyTo with
	// `HTTP_FILTER` is expected to have a match condition on the
	// listeners, with a network filter selection on
	// `envoy.filters.network.http_connection_manager` and a sub filter selection on the
	// HTTP filter relative to which the insertion should be
	// performed. Similarly, an applyTo on `CLUSTER` should have a match
	// (if provided) on the cluster and not on a listener.
	ApplyTo EnvoyFilter_ApplyTo `protobuf:"varint,1,opt,name=apply_to,json=applyTo,proto3,enum=istio.networking.v1alpha3.EnvoyFilter_ApplyTo" json:"apply_to,omitempty"`
	// Match on listener/route configuration/cluster.
	Match *EnvoyFilter_EnvoyConfigObjectMatch `protobuf:"bytes,2,opt,name=match,proto3" json:"match,omitempty"`
	// The patch to apply along with the operation.
	Patch                *EnvoyFilter_Patch `protobuf:"bytes,3,opt,name=patch,proto3" json:"patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) Reset()         { *m = EnvoyFilter_EnvoyConfigObjectPatch{} }
func (m *EnvoyFilter_EnvoyConfigObjectPatch) String() string { return proto.CompactTextString(m) }
func (*EnvoyFilter_EnvoyConfigObjectPatch) ProtoMessage()    {}
func (*EnvoyFilter_EnvoyConfigObjectPatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_16d9b2922bd3e4a9, []int{0, 6}
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Unmarshal(m, b)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Marshal(b, m, deterministic)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Merge(m, src)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_Size() int {
	return xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.Size(m)
}
func (m *EnvoyFilter_EnvoyConfigObjectPatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch.DiscardUnknown(m)
}

var xxx_messageInfo_EnvoyFilter_EnvoyConfigObjectPatch proto.InternalMessageInfo

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetApplyTo() EnvoyFilter_ApplyTo {
	if m != nil {
		return m.ApplyTo
	}
	return EnvoyFilter_INVALID
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetMatch() *EnvoyFilter_EnvoyConfigObjectMatch {
	if m != nil {
		return m.Match
	}
	return nil
}

func (m *EnvoyFilter_EnvoyConfigObjectPatch) GetPatch() *EnvoyFilter_Patch {
	if m != nil {
		return m.Patch
	}
	return nil
}

func init() {
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_ApplyTo", EnvoyFilter_ApplyTo_name, EnvoyFilter_ApplyTo_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_PatchContext", EnvoyFilter_PatchContext_name, EnvoyFilter_PatchContext_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action", EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action_name, EnvoyFilter_RouteConfigurationMatch_RouteMatch_Action_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_Patch_Operation", EnvoyFilter_Patch_Operation_name, EnvoyFilter_Patch_Operation_value)
	proto.RegisterEnum("istio.networking.v1alpha3.EnvoyFilter_Patch_FilterClass", EnvoyFilter_Patch_FilterClass_name, EnvoyFilter_Patch_FilterClass_value)
	proto.RegisterType((*EnvoyFilter)(nil), "istio.networking.v1alpha3.EnvoyFilter")
	proto.RegisterType((*EnvoyFilter_ProxyMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ProxyMatch")
	proto.RegisterMapType((map[string]string)(nil), "istio.networking.v1alpha3.EnvoyFilter.ProxyMatch.MetadataEntry")
	proto.RegisterType((*EnvoyFilter_ClusterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ClusterMatch")
	proto.RegisterType((*EnvoyFilter_RouteConfigurationMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch")
	proto.RegisterType((*EnvoyFilter_RouteConfigurationMatch_RouteMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.RouteMatch")
	proto.RegisterType((*EnvoyFilter_RouteConfigurationMatch_VirtualHostMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.RouteConfigurationMatch.VirtualHostMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_FilterChainMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterChainMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_FilterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.FilterMatch")
	proto.RegisterType((*EnvoyFilter_ListenerMatch_SubFilterMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.ListenerMatch.SubFilterMatch")
	proto.RegisterType((*EnvoyFilter_Patch)(nil), "istio.networking.v1alpha3.EnvoyFilter.Patch")
	proto.RegisterType((*EnvoyFilter_EnvoyConfigObjectMatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectMatch")
	proto.RegisterType((*EnvoyFilter_EnvoyConfigObjectPatch)(nil), "istio.networking.v1alpha3.EnvoyFilter.EnvoyConfigObjectPatch")
}

func init() {
	proto.RegisterFile("networking/v1alpha3/envoy_filter.proto", fileDescriptor_16d9b2922bd3e4a9)
}

var fileDescriptor_16d9b2922bd3e4a9 = []byte{
	// 1351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x72, 0xdb, 0x44,
	0x14, 0x8e, 0xfc, 0xef, 0x63, 0xc7, 0xd9, 0x6e, 0x4a, 0xeb, 0x1a, 0x66, 0x1a, 0x02, 0xc3, 0x94,
	0x81, 0x3a, 0x53, 0x87, 0x61, 0x3a, 0x30, 0x50, 0x1c, 0x47, 0x89, 0x55, 0x12, 0xc9, 0xb3, 0x92,
	0xd3, 0xbf, 0x0b, 0x8d, 0xec, 0x6c, 0x12, 0xb5, 0x8a, 0x64, 0xa4, 0x75, 0xda, 0xcc, 0x70, 0xcb,
	0xf0, 0x14, 0x5c, 0x70, 0xc7, 0x1b, 0x30, 0xdc, 0x73, 0xc7, 0x0b, 0x70, 0xcd, 0x73, 0x70, 0xc1,
	0xec, 0x8f, 0x6c, 0xa7, 0x75, 0x3b, 0x4e, 0xcb, 0xdd, 0xee, 0xb7, 0x7b, 0x3e, 0x7d, 0x67, 0xcf,
	0xd9, 0xb3, 0x47, 0xf0, 0x49, 0x48, 0xd9, 0xf3, 0x28, 0x7e, 0xe6, 0x87, 0xc7, 0x1b, 0x67, 0x77,
	0xbc, 0x60, 0x74, 0xe2, 0x6d, 0x6e, 0xd0, 0xf0, 0x2c, 0x3a, 0x77, 0x8f, 0xfc, 0x80, 0xd1, 0xb8,
	0x39, 0x8a, 0x23, 0x16, 0xe1, 0x1b, 0x7e, 0xc2, 0xfc, 0xa8, 0x39, 0xdd, 0xdd, 0x4c, 0x77, 0x37,
	0x6e, 0x1e, 0x47, 0xd1, 0x71, 0x40, 0x37, 0xbc, 0x91, 0xbf, 0x71, 0xe4, 0xd3, 0xe0, 0xd0, 0x1d,
	0xd0, 0x13, 0xef, 0xcc, 0x8f, 0x94, 0x6d, 0xe3, 0x03, 0xb5, 0x41, 0xcc, 0x06, 0xe3, 0xa3, 0x8d,
	0x84, 0xc5, 0xe3, 0x21, 0x53, 0xab, 0x1f, 0xce, 0x53, 0x90, 0xf8, 0x87, 0x74, 0xe8, 0x29, 0x82,
	0xf5, 0xdf, 0x6f, 0x40, 0x45, 0xe7, 0x9a, 0x76, 0x84, 0x24, 0xfc, 0x10, 0xae, 0x70, 0x8b, 0x20,
	0xf2, 0x0e, 0xdd, 0x84, 0x06, 0x74, 0xc8, 0xa2, 0xb8, 0x9e, 0x5d, 0xd3, 0x6e, 0x55, 0x5a, 0x9f,
	0x35, 0x5f, 0x2b, 0xb4, 0xf9, 0x40, 0xd9, 0xd8, 0xca, 0x84, 0xa0, 0xe7, 0x2f, 0x21, 0xf8, 0x29,
	0xd4, 0x86, 0x51, 0x78, 0xe4, 0x1f, 0xbb, 0x23, 0x8f, 0x0d, 0x4f, 0x68, 0x52, 0xcf, 0xad, 0x65,
	0x6f, 0x55, 0x5a, 0xdf, 0xbc, 0x81, 0x76, 0x46, 0x99, 0x1c, 0x77, 0x04, 0x83, 0x35, 0x78, 0x4a,
	0x87, 0xac, 0xc7, 0x69, 0xb6, 0x72, 0xff, 0xb4, 0xb5, 0x0c, 0x59, 0x96, 0xd4, 0x3d, 0xc9, 0xdc,
	0xf8, 0x4b, 0x03, 0xe8, 0xc5, 0xd1, 0x8b, 0xf3, 0x7d, 0x0e, 0xe0, 0x8f, 0x60, 0x79, 0xc4, 0x67,
	0xee, 0x19, 0x8d, 0x13, 0x3f, 0x0a, 0xeb, 0xda, 0x9a, 0x76, 0xab, 0x4c, 0xaa, 0x02, 0x3c, 0x90,
	0x18, 0x7e, 0x02, 0xa5, 0x53, 0xca, 0xbc, 0x43, 0x8f, 0x79, 0xf5, 0x8c, 0x50, 0x76, 0x6f, 0x41,
	0x65, 0xd3, 0x2f, 0x35, 0xf7, 0x15, 0x83, 0x1e, 0xb2, 0xf8, 0x9c, 0x4c, 0x08, 0x1b, 0x5f, 0xc3,
	0xf2, 0x85, 0x25, 0x8c, 0x20, 0xfb, 0x8c, 0x9e, 0x2b, 0x21, 0x7c, 0x88, 0xaf, 0x42, 0xfe, 0xcc,
	0x0b, 0xc6, 0xb4, 0x9e, 0x11, 0x98, 0x9c, 0x7c, 0x95, 0xb9, 0xab, 0x35, 0xc6, 0x50, 0xed, 0x04,
	0xe3, 0x84, 0xd1, 0x58, 0xba, 0x73, 0x13, 0x2a, 0xa3, 0x28, 0x66, 0x6e, 0x38, 0x3e, 0x1d, 0xd0,
	0x58, 0x70, 0x2c, 0x13, 0xe0, 0x90, 0x29, 0x10, 0x5c, 0x87, 0x62, 0x42, 0xe3, 0x33, 0x7f, 0x98,
	0x92, 0xa5, 0x53, 0x7c, 0x0d, 0x0a, 0xc9, 0x78, 0x90, 0x50, 0x26, 0x62, 0x5a, 0x26, 0x6a, 0x86,
	0x31, 0xe4, 0x42, 0xef, 0x94, 0xd6, 0x73, 0x02, 0x15, 0xe3, 0xc6, 0x9f, 0x39, 0xb8, 0x4e, 0xa2,
	0x31, 0xa3, 0xf2, 0xd0, 0xc7, 0xb1, 0xc7, 0xfc, 0x28, 0x5c, 0x50, 0xc2, 0xfb, 0x50, 0x96, 0x1b,
	0x38, 0xab, 0x14, 0x51, 0x12, 0xcb, 0xde, 0x29, 0xe5, 0xfa, 0x8e, 0x3d, 0x46, 0x9f, 0x7b, 0xe7,
	0x4a, 0x46, 0x3a, 0xc5, 0x14, 0xf2, 0x67, 0x27, 0x51, 0xc2, 0x84, 0x90, 0x4a, 0xcb, 0x5a, 0x30,
	0x02, 0xaf, 0x91, 0xd9, 0x3c, 0xf0, 0x63, 0x36, 0xf6, 0x82, 0x6e, 0x94, 0x30, 0x01, 0x10, 0xc9,
	0x3e, 0x71, 0x37, 0x3f, 0xe3, 0x2e, 0xcf, 0x19, 0xc1, 0x23, 0x3d, 0x4c, 0xb7, 0x68, 0xd3, 0x2d,
	0xf8, 0x04, 0x0a, 0xde, 0x90, 0xb3, 0x0b, 0x8f, 0x6a, 0xad, 0xde, 0x3b, 0xca, 0x9b, 0x7e, 0xae,
	0xd9, 0x16, 0xbc, 0x44, 0xf1, 0xaf, 0xdf, 0x83, 0x82, 0x44, 0x70, 0x11, 0xb2, 0x6d, 0xf3, 0x11,
	0x5a, 0xc2, 0x65, 0xc8, 0x13, 0xab, 0xef, 0xe8, 0x48, 0xc3, 0x55, 0x28, 0x11, 0x7d, 0xdb, 0x20,
	0x7a, 0xc7, 0x41, 0x19, 0xbc, 0x0a, 0x2b, 0x72, 0xec, 0x12, 0xdd, 0xee, 0x59, 0xa6, 0xad, 0xa3,
	0x6c, 0xe3, 0x67, 0x0d, 0xd0, 0xcb, 0xde, 0xcf, 0xf5, 0xc9, 0x85, 0x7c, 0xcc, 0x65, 0x08, 0x97,
	0x2a, 0x2d, 0xe3, 0x7f, 0x73, 0x89, 0x48, 0xde, 0xc6, 0x2f, 0x79, 0x58, 0xde, 0xf3, 0x13, 0x46,
	0xc3, 0x85, 0xf3, 0xf7, 0x8d, 0xc9, 0x73, 0x02, 0x55, 0x59, 0x3e, 0xdd, 0xe1, 0x89, 0xe7, 0x87,
	0xaa, 0x38, 0xe9, 0x0b, 0xea, 0xbe, 0xa0, 0xa4, 0x29, 0xc1, 0x0e, 0xe7, 0x91, 0x9a, 0x2b, 0x47,
	0x53, 0x64, 0xee, 0xa5, 0xf8, 0x35, 0x03, 0xe8, 0x65, 0xab, 0xb9, 0xe7, 0x8a, 0x20, 0x9b, 0x84,
	0xbe, 0x52, 0xcf, 0x87, 0xf8, 0x36, 0x60, 0x16, 0x7b, 0x61, 0x22, 0x5c, 0x13, 0xd5, 0x77, 0x18,
	0x05, 0xea, 0x02, 0x5c, 0x99, 0xac, 0xf4, 0xd4, 0x02, 0xde, 0x84, 0xf7, 0xbc, 0xd1, 0x28, 0xf0,
	0x87, 0xe2, 0x74, 0x27, 0x06, 0x89, 0x92, 0x73, 0x75, 0x66, 0x31, 0xb5, 0x49, 0xf0, 0x43, 0x28,
	0x48, 0x0f, 0x44, 0x6a, 0x57, 0x5a, 0xdf, 0xbd, 0xc3, 0xb1, 0xc8, 0x13, 0x51, 0x7c, 0xf8, 0x53,
	0x40, 0x87, 0x34, 0x61, 0x7e, 0xa8, 0xe4, 0x44, 0x31, 0xab, 0x17, 0x44, 0xe4, 0x56, 0x66, 0xf0,
	0x5e, 0x14, 0xb3, 0xc6, 0x4f, 0x1a, 0x54, 0x66, 0x28, 0xe6, 0x1e, 0xcf, 0x00, 0x20, 0x19, 0x0f,
	0xd4, 0x43, 0xa8, 0x72, 0xaf, 0xf3, 0x56, 0x62, 0xed, 0xf1, 0x60, 0x56, 0x6f, 0x39, 0x49, 0xe7,
	0x8d, 0x8f, 0xa1, 0x76, 0x71, 0x71, 0x9e, 0x92, 0xc6, 0x6f, 0x59, 0xc8, 0x8b, 0x77, 0x03, 0x3b,
	0x50, 0x8e, 0x46, 0x54, 0x66, 0xb3, 0xd8, 0x52, 0x6b, 0x7d, 0xb9, 0xe8, 0x13, 0x20, 0xa4, 0x58,
	0xa9, 0x35, 0x99, 0x12, 0xe1, 0xdb, 0xb3, 0x75, 0xbd, 0xd2, 0xba, 0xde, 0x94, 0x4f, 0x76, 0x33,
	0x7d, 0xb2, 0x9b, 0xb6, 0x78, 0xb2, 0x55, 0xc1, 0xc7, 0x4f, 0xa6, 0xe9, 0x1d, 0x78, 0x49, 0x22,
	0xf2, 0xa3, 0xd6, 0xba, 0x7b, 0x29, 0x1d, 0x2a, 0x41, 0xb9, 0xfd, 0x24, 0xa3, 0xf9, 0x64, 0xfd,
	0x47, 0x28, 0x4f, 0x34, 0xe2, 0x0a, 0x14, 0x0d, 0xf3, 0xa0, 0xbd, 0x67, 0x6c, 0xcb, 0xea, 0xb2,
	0xaf, 0x93, 0x5d, 0x5e, 0x5d, 0x78, 0xc5, 0xd9, 0xde, 0x46, 0x19, 0x0c, 0x50, 0x20, 0xfa, 0xbe,
	0x75, 0xa0, 0xa3, 0x2c, 0xbe, 0x02, 0xcb, 0x86, 0x69, 0xeb, 0xc4, 0x71, 0xb7, 0xf4, 0x1d, 0x8b,
	0xe8, 0x28, 0x87, 0x11, 0x54, 0x15, 0xd4, 0xde, 0x71, 0x74, 0x82, 0xf2, 0x33, 0xc8, 0x8e, 0x41,
	0x6c, 0x07, 0x15, 0xf8, 0x37, 0x88, 0xde, 0xdb, 0x6b, 0x77, 0x74, 0x54, 0x5c, 0xbf, 0x97, 0xa6,
	0x85, 0x10, 0x83, 0x57, 0xa0, 0xd2, 0x37, 0xed, 0x9e, 0xde, 0x31, 0x76, 0x0c, 0x5d, 0x69, 0x68,
	0xf7, 0x9d, 0xae, 0x89, 0xb4, 0x74, 0xf8, 0x18, 0x65, 0xf8, 0xd0, 0x76, 0xda, 0x8e, 0x8d, 0xb2,
	0x8d, 0xbf, 0xb3, 0x70, 0xed, 0x95, 0x36, 0x40, 0x46, 0x76, 0x1f, 0x8a, 0xc3, 0x28, 0x64, 0xf4,
	0x05, 0x53, 0x91, 0xdb, 0xbc, 0xcc, 0x89, 0x75, 0xa4, 0x29, 0x49, 0x39, 0xf0, 0x2e, 0xe4, 0x45,
	0x73, 0xa0, 0x82, 0x76, 0xe7, 0xd2, 0x9d, 0x00, 0x91, 0xf6, 0x98, 0x40, 0x29, 0x50, 0xe9, 0xaa,
	0x2a, 0xd5, 0x17, 0x6f, 0x93, 0xe5, 0xdd, 0x25, 0x32, 0xe1, 0xc1, 0x3f, 0xc0, 0xaa, 0x28, 0xad,
	0xee, 0x70, 0xb6, 0xfe, 0xaa, 0x27, 0xf3, 0xdb, 0x77, 0x2b, 0xe0, 0xdd, 0x25, 0x82, 0xe3, 0x57,
	0x96, 0xb0, 0x05, 0xc5, 0xa1, 0x6c, 0x41, 0x54, 0x61, 0x59, 0xf4, 0x78, 0x67, 0x1b, 0x97, 0xee,
	0x12, 0x49, 0x59, 0xb6, 0x6a, 0x50, 0x8d, 0x44, 0xf8, 0x5c, 0x76, 0x3e, 0xa2, 0x49, 0xe3, 0x5f,
	0x6d, 0x4e, 0x68, 0xe5, 0xb5, 0x34, 0xa0, 0xc4, 0x6b, 0xdd, 0xb9, 0xcb, 0x22, 0x15, 0xdb, 0xe6,
	0x82, 0x1f, 0x6f, 0x73, 0x33, 0x27, 0x22, 0x45, 0x4f, 0x0e, 0xb0, 0x0d, 0xf9, 0x53, 0xce, 0xa9,
	0xc2, 0xfa, 0xd6, 0xad, 0xa7, 0x0a, 0xb1, 0xe0, 0xc2, 0x5b, 0x90, 0x17, 0x1d, 0xad, 0x8a, 0xef,
	0xe7, 0x97, 0x49, 0x3c, 0x22, 0x4d, 0xd7, 0xff, 0xd0, 0xa0, 0xa8, 0xd4, 0x5e, 0xbc, 0x97, 0x55,
	0x28, 0xed, 0x19, 0xb6, 0xa3, 0x9b, 0x3a, 0x41, 0x1a, 0xbf, 0x60, 0x3b, 0xc6, 0x9e, 0xa3, 0x13,
	0xb7, 0xd3, 0x6d, 0x1b, 0x26, 0xca, 0x60, 0x0c, 0x35, 0x53, 0x77, 0x1e, 0x58, 0xe4, 0x7b, 0x57,
	0xae, 0xa0, 0x2c, 0xbf, 0x58, 0x5d, 0xc7, 0xe9, 0xa5, 0x40, 0x0e, 0x5f, 0x87, 0x55, 0xd1, 0x3a,
	0xb8, 0x1d, 0xcb, 0xdc, 0x31, 0x76, 0xfb, 0xa4, 0xed, 0x18, 0x96, 0x29, 0x2f, 0xec, 0x81, 0x41,
	0x9c, 0x7e, 0x7b, 0xcf, 0xed, 0x5a, 0xe2, 0xc2, 0xd6, 0x00, 0x84, 0xad, 0x6c, 0x35, 0x8a, 0x5c,
	0x4c, 0x67, 0xaf, 0x6f, 0x73, 0x9e, 0x12, 0xbe, 0x0a, 0x48, 0x7f, 0xe8, 0xe8, 0xa6, 0x6d, 0x58,
	0xa6, 0xe2, 0x42, 0xe5, 0x75, 0x0b, 0xaa, 0xb3, 0x97, 0x68, 0xda, 0xb1, 0xac, 0xc2, 0x8a, 0x6d,
	0x6c, 0xeb, 0x9d, 0x36, 0x71, 0x0d, 0x73, 0xcb, 0xea, 0x9b, 0xdb, 0x48, 0xe3, 0x1c, 0x29, 0x68,
	0xf5, 0x1d, 0x89, 0x66, 0xf8, 0x67, 0x76, 0xdb, 0x8e, 0xfe, 0xa0, 0xfd, 0x08, 0x65, 0xef, 0xe7,
	0x4a, 0x1a, 0xca, 0xdc, 0xcf, 0x95, 0x32, 0x28, 0x4b, 0x8a, 0xb2, 0x7c, 0x25, 0x64, 0x65, 0xf2,
	0x5b, 0x12, 0x78, 0x03, 0x1a, 0x24, 0x5b, 0xeb, 0x8f, 0xd7, 0xe4, 0x41, 0xfb, 0x91, 0xf8, 0x3f,
	0x9a, 0xf3, 0xaf, 0x33, 0x28, 0x88, 0x22, 0xbb, 0xf9, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
	0xa9, 0x1e, 0x38, 0x8b, 0x0d, 0x00, 0x00,
}
